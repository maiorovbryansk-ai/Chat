<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Messenger</title>
<link rel="icon" href="data:;base64,iVBORw0KGgo=" />
<style>
  :root{
    --bg:#0f1724;
    --card:#0b1220;
    --muted:#94a3b8;
    --accent:#7c5cff;
    --text:#e6eef8;
    --glass: rgba(255,255,255,0.03);
    --radius:12px;
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  *{box-sizing:border-box}
  html,body,#app{height:100%;margin:0;background:linear-gradient(180deg,#071025 0%, #061623 100%);color:var(--text)}
  .app{display:flex;flex-direction:column;height:100vh;padding:16px;gap:12px}
  .shell{display:grid;grid-template-columns:360px 1fr;gap:16px;height:calc(100vh - 64px)}
  @media(max-width:800px){ .shell{grid-template-columns:1fr} }
  .card{background:var(--card);border-radius:var(--radius);padding:12px;box-shadow: 0 6px 18px rgba(2,6,23,0.6);overflow:hidden}
  .auth-screen{max-width:420px;margin:auto}
  h1{font-size:20px;margin:0 0 8px 0}
  small{color:var(--muted)}
  input,button,textarea{font:inherit}
  .field{display:flex;flex-direction:column;gap:6px;margin:8px 0}
  input,textarea{background:var(--glass);border:1px solid rgba(255,255,255,0.04);padding:10px;border-radius:10px;color:var(--text);outline:none}
  button{background:var(--accent);border:none;color:white;padding:10px 12px;border-radius:10px;cursor:pointer}
  .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
  .muted{color:var(--muted);font-size:13px}
  .chats-list{display:flex;flex-direction:column;height:100%}
  .chat-item{display:flex;align-items:center;gap:12px;padding:10px;border-radius:10px;cursor:pointer}
  .chat-item:hover{background:rgba(255,255,255,0.02)}
  .nick{font-weight:600}
  .right{margin-left:auto;font-size:12px;color:var(--muted)}
  .search{display:flex;gap:8px;align-items:center}
  .messages{display:flex;flex-direction:column;height:100%;gap:12px}
  .messages-window{flex:1;overflow:auto;padding:12px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent)}
  .msg{max-width:70%;padding:10px;border-radius:12px;margin:8px 0;word-break:break-word}
  .msg.me{margin-left:auto;background:linear-gradient(90deg,var(--accent),#5a45d6);color:white}
  .msg.other{background:rgba(255,255,255,0.02)}
  .msg-meta{font-size:12px;color:var(--muted);margin-top:6px;display:flex;gap:8px;align-items:center}
  .reactions{display:flex;gap:6px;margin-left:6px}
  .reaction{padding:4px 6px;border-radius:999px;font-size:14px;cursor:pointer;border:1px solid rgba(255,255,255,0.03)}
  .reaction.active{background:rgba(255,255,255,0.06)}
  .composer{display:flex;gap:8px;padding-top:8px}
  .composer input{flex:1}
  .topbar{display:flex;align-items:center;gap:12px;justify-content:space-between}
  .empty{display:flex;align-items:center;justify-content:center;height:100%;color:var(--muted)}
  .logo{font-weight:700;color:var(--accent)}
  .small{font-size:13px}
  .notice{background:rgba(124,92,255,0.09);padding:8px;border-radius:8px;color:var(--accent);font-size:13px}
</style>
</head>
<body>
<div id="app" class="app">
  <div class="topbar">
    <div style="display:flex;align-items:center;gap:12px">
      <div class="logo">Messenger</div>
      <div class="small muted">1-–Ω–∞-1, —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç-–∫–ª–∏–µ–Ω—Ç –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ</div>
    </div>
    <div id="authControls"></div>
  </div>

  <div id="main" class="shell">
    <!-- Left: chats + search -->
    <div style="display:flex;flex-direction:column;gap:12px;">
      <div class="card">
        <div style="display:flex;gap:8px;align-items:center;">
          <div style="font-weight:700">–ß–∞—Ç—ã</div>
          <div class="right muted" id="onlineStatus">offline</div>
        </div>
        <div style="margin-top:10px" class="search">
          <input id="searchInput" placeholder="–ò—Å–∫–∞—Ç—å @nickname" />
          <button id="searchBtn" class="btn-ghost">–ü–æ–∏—Å–∫</button>
        </div>
      </div>

      <div class="card chats-list" id="chatsListContainer" style="overflow:auto">
        <!-- chat items -->
      </div>

    </div>

    <!-- Right: chat window or auth -->
    <div style="display:flex;flex-direction:column;gap:12px;">
      <div id="rightCard" class="card" style="min-height:360px;display:flex;flex-direction:column;">
        <!-- dynamic screens -->
        <div id="authScreen" class="auth-screen" style="display:none"></div>
        <div id="searchScreen" style="display:none"></div>
        <div id="chatScreen" style="display:none;flex:1;min-height:0"></div>
      </div>
    </div>
  </div>
</div>

<script type="module">
/* ----------------- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è: –≤—Å—Ç–∞–≤—å —Å–≤–æ–∏ –∑–Ω–∞—á–µ–Ω–∏—è ----------------- */
const SUPABASE_URL = "REPLACE_WITH_SUPABASE_URL";
const SUPABASE_ANON_KEY = "REPLACE_WITH_SUPABASE_ANON_KEY";
/* -------------------------------------------------------------------- */

import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm";

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

const EMOJI_SET = ["üëç","‚ù§Ô∏è","üòÇ","üòÆ","üò¢","üò°"];

let state = {
  user: null,
  profile: null,
  chats: [], // {id, other_id, other_nick, last_message, last_at}
  activeChatId: null,
  messages: {}, // chatId -> [messages]
  reactions: {}, // messageId -> {reaction -> count, byUser: 'üëç' or null}
  subMessages: null,
  subReactions: null
};

/* ---------------- Utilities ---------------- */
const $ = sel => document.querySelector(sel);
const el = (tag, attrs={}, children=[]) => {
  const e = document.createElement(tag);
  Object.entries(attrs).forEach(([k,v])=>{
    if(k === "class") e.className = v;
    else if(k.startsWith("on")) e.addEventListener(k.slice(2), v);
    else e.setAttribute(k, v);
  });
  (Array.isArray(children) ? children : [children]).forEach(c=>{
    if(typeof c === "string") e.appendChild(document.createTextNode(c));
    else if(c) e.appendChild(c);
  });
  return e;
};
const fmtTime = dt => {
  const d = new Date(dt);
  return d.toLocaleString();
};
const notifyPermission = async () => {
  if (!("Notification" in window)) return false;
  if (Notification.permission === "granted") return true;
  if (Notification.permission !== "denied") {
    const p = await Notification.requestPermission();
    return p === "granted";
  }
  return false;
};

/* ---------------- Auth UI & Flow ---------------- */
const authControls = $("#authControls");
const authScreen = $("#authScreen");
const chatScreen = $("#chatScreen");
const searchScreen = $("#searchScreen");
const chatsListContainer = $("#chatsListContainer");
const searchInput = $("#searchInput");
const searchBtn = $("#searchBtn");
const onlineStatus = $("#onlineStatus");

function showAuth() {
  authScreen.style.display = "block";
  chatScreen.style.display = "none";
  searchScreen.style.display = "none";
  renderAuthScreen();
}

function showMainUI() {
  authScreen.style.display = "none";
  chatScreen.style.display = "block";
  searchScreen.style.display = "none";
  renderTopAuthControls();
  refreshChatsList();
  subscribeRealtime();
}

function renderTopAuthControls(){
  authControls.innerHTML = "";
  if (!state.user) return;
  const nick = state.profile?.nickname || "@–Ω–µ –∑–∞–¥–∞–Ω";
  const email = state.user.email || "";
  const div = el("div", {style:"display:flex;gap:8px;align-items:center"});
  div.appendChild(el("div", {}, [`${nick}`]));
  const out = el("button", {onClick:logout, class:"btn-ghost"}, ["–í—ã–π—Ç–∏"]);
  div.appendChild(out);
  authControls.appendChild(div);
}

function renderAuthScreen(){
  authScreen.innerHTML = "";
  const wrap = el("div", {}, [
    el("h1", {}, ["–í—Ö–æ–¥ / –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è"]),
    el("div", {class:"muted"}, ["Email + –ø–∞—Ä–æ–ª—å. –ü–æ—Å–ª–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –Ω—É–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –Ω–∏–∫ @nickname."])
  ]);
  const emailF = el("input", {placeholder:"Email", id:"authEmail"});
  const passF = el("input", {placeholder:"–ü–∞—Ä–æ–ª—å", type:"password", id:"authPass"});
  const signInBtn = el("button", {onClick:signin}, ["–í–æ–π—Ç–∏"]);
  const signUpBtn = el("button", {onClick:signup}, ["–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è"]);
  const nicknameWrap = el("div", {id:"nicknameSetup", style:"margin-top:12px;display:none"});
  const nickInput = el("input", {placeholder:"@nickname", id:"nickInput"});
  const nickSave = el("button", {onClick:saveNickname}, ["–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∏–∫"]);
  nicknameWrap.appendChild(nickInput); nicknameWrap.appendChild(nickSave);

  wrap.appendChild(el("div", {class:"field"}, [emailF, passF]));
  wrap.appendChild(el("div", {style:"display:flex;gap:8px"}, [signInBtn, signUpBtn]));
  wrap.appendChild(nicknameWrap);
  authScreen.appendChild(wrap);
}

async function signup(){
  const email = $("#authEmail").value.trim();
  const password = $("#authPass").value;
  if(!email || !password){ alert("–ó–∞–ø–æ–ª–Ω–∏ email –∏ –ø–∞—Ä–æ–ª—å"); return; }
  const { data, error } = await supabase.auth.signUp({ email, password });
  if (error) return alert(error.message);
  // –µ—Å–ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è user ‚Äî –º–æ–∂–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–∏–∫ —Å—Ä–∞–∑—É; –∏–Ω–∞—á–µ –ø—Ä–æ—Å–∏–º –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å email –∏ –≤–æ–π—Ç–∏
  if (data?.user){
    state.user = data.user;
    // show nickname setup
    document.getElementById("nicknameSetup").style.display = "block";
    alert("–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏ —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –Ω–∏–∫ (—Ñ–æ—Ä–º–∞—Ç @nickname).");
  } else {
    alert("–ü—Ä–æ–≤–µ—Ä—å –ø–æ—á—Ç—É: —Ç–µ–±–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–∏—Å—å–º–æ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è. –ü–æ—Å–ª–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –≤–æ–π–¥–∏ –∏ —É—Å—Ç–∞–Ω–æ–≤–∏ –Ω–∏–∫–Ω–µ–π–º.");
  }
}

async function signin(){
  const email = $("#authEmail").value.trim();
  const password = $("#authPass").value;
  if(!email || !password){ alert("–ó–∞–ø–æ–ª–Ω–∏ email –∏ –ø–∞—Ä–æ–ª—å"); return; }
  const { data, error } = await supabase.auth.signInWithPassword({ email, password });
  if (error) return alert(error.message);
  state.user = data.user;
  // load profile, if missing ask to set nickname
  const { data: profile, error: pErr } = await supabase.from("profiles").select("*").eq("id", state.user.id).single();
  if (pErr && pErr.code !== "PGRST116") {
    // PGRST116 = no rows? client lib codes vary; ignore generic
  }
  if (!profile) {
    // show nickname setup
    showAuth();
    document.getElementById("nicknameSetup").style.display = "block";
  } else {
    state.profile = profile;
    showMainUI();
  }
}

async function saveNickname(){
  const v = document.getElementById("nickInput").value.trim();
  if(!v || !v.startsWith("@")) return alert("–ù–∏–∫ –¥–æ–ª–∂–µ–Ω –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å @");
  if(!state.user) return alert("–°–Ω–∞—á–∞–ª–∞ –≤–æ–π–¥–∏");
  // check uniqueness
  const { data: existing } = await supabase.from("profiles").select("id").ilike("nickname", v).limit(1);
  if (existing && existing.length>0) return alert("–ù–∏–∫ —É–∂–µ –∑–∞–Ω—è—Ç");
  const { data, error } = await supabase.from("profiles").insert([{
    id: state.user.id,
    email: state.user.email,
    nickname: v
  }]);
  if (error) return alert(error.message);
  state.profile = data[0];
  document.getElementById("nicknameSetup").style.display = "none";
  showMainUI();
}

async function logout(){
  await supabase.auth.signOut();
  state.user = null;
  state.profile = null;
  renderAuthScreen();
  authControls.innerHTML = "";
  authScreen.style.display = "block";
  chatScreen.style.display = "none";
}

/* ---------------- Search users & open chat ---------------- */
searchBtn.addEventListener("click", async ()=>{
  const q = searchInput.value.trim();
  if(!q) return alert("–í–≤–µ–¥–∏ @nickname");
  await searchUsers(q);
});

async function searchUsers(q){
  searchScreen.style.display = "block";
  chatScreen.style.display = "none";
  const elWrap = $("#searchScreen");
  elWrap.innerHTML = "";
  elWrap.appendChild(el("div", {class:"small muted"}, [`–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ –¥–ª—è ${q}`]));
  // exact or startswith
  const { data, error } = await supabase.from("profiles").select("id,nickname,created_at").ilike("nickname", `${q}%`).limit(20);
  if (error) return alert(error.message);
  if (!data || data.length === 0){
    elWrap.appendChild(el("div", {class:"empty"}, ["–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã"]));
    return;
  }
  data.forEach(row=>{
    const item = el("div", {class:"chat-item"}, [
      el("div", {class:"nick"}, [row.nickname]),
      el("div", {class:"muted right"}, [new Date(row.created_at).toLocaleDateString()])
    ]);
    item.addEventListener("click", ()=> openChatWithUser(row));
    elWrap.appendChild(item);
  });
}

async function openChatWithUser(userProfile){
  // call RPC to create or return existing private chat
  if(!state.user) return alert("–í–æ–π–¥–∏ —Å–Ω–∞—á–∞–ª–∞");
  const creator = state.user.id;
  const other = userProfile.id;
  try{
    const { data, error } = await supabase.rpc("create_private_chat", {creator_uuid: creator, other_uuid: other});
    if (error) throw error;
    const chatId = data;
    await openChat(chatId);
    // switch UI
    chatScreen.style.display = "block";
    searchScreen.style.display = "none";
  } catch(e){
    alert("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —á–∞—Ç–∞: " + e.message);
  }
}

/* ---------------- Chats list & messages ---------------- */
async function refreshChatsList(){
  if(!state.user) return;
  // fetch chats where user is member, join to get other participant and last message
  const sql = `
    select c.id, c.created_at,
      (select json_agg(p) from (
         select id, nickname from profiles p
         join chat_members cm on cm.member_id = p.id
         where cm.chat_id = c.id and p.id <> '${state.user.id}'
       ) as t) as other_profiles,
      (select (select text from messages m2 where m2.chat_id = c.id order by created_at desc limit 1)) as last_message,
      (select (select created_at from messages m2 where m2.chat_id = c.id order by created_at desc limit 1)) as last_at
    from chats c
    join chat_members cm on cm.chat_id = c.id
    where cm.member_id = '${state.user.id}'
    order by last_at desc nulls last, c.created_at desc
    limit 100;
  `;
  // use RPC query? supabase.from().select supports embedding via SQL? Simpler: use postgrest filtered queries with joins
  const { data, error } = await supabase
    .from("chat_members")
    .select(`
      chat:chats!inner(id,created_at),
      chat(messages:text,created_at),
      chat:chats!inner(
        chat_members!inner(member_id)
      )
    `)
    .eq("member_id", state.user.id)
    .limit(200);
  // The above is complicated via PostgREST. Instead do two queries: fetch chats ids then fetch last message and other profile.
  const { data: chatRows, error: e2 } = await supabase
    .from("chat_members")
    .select("chat_id")
    .eq("member_id", state.user.id);
  if (e2) return console.error(e2);
  const ids = chatRows.map(r=>r.chat_id);
  if (ids.length === 0){
    chatsListContainer.innerHTML = '<div class="empty">–ù–µ—Ç —á–∞—Ç–æ–≤. –ù–∞–π–¥–∏ –ª—é–¥–µ–π —á–µ—Ä–µ–∑ –ø–æ–∏—Å–∫.</div>';
    return;
  }
  // fetch chat metadata
  const { data: chatsMeta } = await supabase.from("chats").select("id,created_at").in("id", ids);
  // fetch last messages for these chats
  const { data: lastMsgs } = await supabase
    .from("messages")
    .select("id,chat_id,sender_id,text,created_at")
    .in("chat_id", ids)
    .order("created_at", { ascending: false })
    .limit(200);
  const lastByChat = {};
  (lastMsgs||[]).forEach(m=>{
    if(!lastByChat[m.chat_id]) lastByChat[m.chat_id] = m;
    else if (new Date(m.created_at) > new Date(lastByChat[m.chat_id].created_at)) lastByChat[m.chat_id] = m;
  });
  // fetch other participants
  const { data: members } = await supabase
    .from("chat_members")
    .select("chat_id,member_id,profiles(nickname)")
    .in("chat_id", ids);
  const mapOther = {};
  members.forEach(m=>{
    if(m.member_id !== state.user.id){
      mapOther[m.chat_id] = m.profiles;
    }
  });
  // build state.chats
  state.chats = chatsMeta.map(c => ({
    id: c.id,
    created_at: c.created_at,
    other: mapOther[c.id] || {nickname: "@unknown"},
    last_message: lastByChat[c.id]?.text || "",
    last_at: lastByChat[c.id]?.created_at || c.created_at
  }));
  renderChatsList();
}

function renderChatsList(){
  chatsListContainer.innerHTML = "";
  if (!state.chats || state.chats.length === 0){
    chatsListContainer.innerHTML = '<div class="empty">–ù–µ—Ç —á–∞—Ç–æ–≤. –ù–∞–π–¥–∏ –ª—é–¥–µ–π —á–µ—Ä–µ–∑ –ø–æ–∏—Å–∫.</div>';
    return;
  }
  state.chats.forEach(c=>{
    const item = el("div", {class:"chat-item"}, [
      el("div", {}, [c.other.nickname || "@unknown"]),
      el("div", {class:"muted right"}, [c.last_message ? new Date(c.last_at).toLocaleTimeString() : ""])
    ]);
    item.addEventListener("click", ()=> openChat(c.id));
    chatsListContainer.appendChild(item);
  });
}

async function openChat(chatId){
  state.activeChatId = chatId;
  chatScreen.innerHTML = "";
  const header = el("div", {style:"display:flex;align-items:center;gap:8px;justify-content:space-between"});
  const otherNick = (state.chats.find(c=>c.id===chatId)?.other?.nickname) || "@—á–∞—Ç";
  header.appendChild(el("div", {style:"font-weight:700"}, [otherNick]));
  const open = el("div", {}, [
    el("button", {onClick: ()=>{ /* placeholder */ }, class:"btn-ghost"}, ["–ò–Ω—Ñ–æ"])
  ]);
  header.appendChild(open);
  chatScreen.appendChild(header);

  const messagesWrap = el("div", {class:"messages", style:"flex:1;min-height:0"});
  const win = el("div", {class:"messages-window", id:"messagesWindow"});
  messagesWrap.appendChild(win);
  // composer
  const composer = el("div", {class:"composer"}, [
    el("input", {placeholder:"–ù–∞–ø–∏—Å–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ...", id:"messageInput"}),
    el("button", {onClick:sendMessage}, ["–û—Ç–ø—Ä–∞–≤–∏—Ç—å"])
  ]);
  chatScreen.appendChild(messagesWrap);
  chatScreen.appendChild(composer);

  // load messages
  await loadMessages(chatId);
  // scroll to bottom
  setTimeout(()=> scrollToBottom(), 50);
}

async function loadMessages(chatId){
  const { data, error } = await supabase
    .from("messages")
    .select("id,chat_id,sender_id,text,created_at")
    .eq("chat_id", chatId)
    .order("created_at", { ascending: true })
    .limit(1000);
  if (error) return console.error(error);
  state.messages[chatId] = data || [];
  // load reactions
  const { data: reacts } = await supabase.from("message_reactions").select("id,message_id,user_id,reaction");
  state.reactions = {};
  (reacts||[]).forEach(r=>{
    state.reactions[r.message_id] = state.reactions[r.message_id] || {counts:{}, byUser:null};
    state.reactions[r.message_id].counts[r.reaction] = (state.reactions[r.message_id].counts[r.reaction]||0)+1;
    if (r.user_id === state.user.id) state.reactions[r.message_id].byUser = r.reaction;
  });
  renderMessages(chatId);
}

function renderMessages(chatId){
  const win = document.getElementById("messagesWindow");
  win.innerHTML = "";
  const msgs = state.messages[chatId] || [];
  msgs.forEach(m=>{
    const isMe = m.sender_id === state.user.id;
    const mdiv = el("div", {class:"msg " + (isMe ? "me" : "other")}, [
      el("div", {}, [m.text]),
      el("div", {class:"msg-meta"}, [
        el("div", {class:"muted"}, [ (isMe? "–¢—ã" : "") + " ‚Ä¢ " + new Date(m.created_at).toLocaleString() ]),
        el("div", {class:"reactions"}, [ renderReactionsUI(m) ])
      ])
    ]);
    win.appendChild(mdiv);
  });
  scrollToBottom();
}

function renderReactionsUI(message){
  const wrapper = el("div");
  const rstate = state.reactions[message.id] || {counts:{}, byUser:null};
  EMOJI_SET.forEach(em=>{
    const count = rstate.counts[em] || 0;
    const btn = el("span", {class:"reaction " + ((rstate.byUser === em) ? "active" : ""), onclick: ()=> toggleReaction(message, em) }, [ count ? `${em} ${count}` : em ]);
    wrapper.appendChild(btn);
  });
  return wrapper;
}

async function toggleReaction(message, em){
  if (!state.user) return alert("–í–æ–π–¥–∏ –¥–ª—è —Ä–µ–∞–∫—Ü–∏–∏");
  const existing = state.reactions[message.id]?.byUser || null;
  try {
    if (existing === em) {
      // remove reaction
      const { error } = await supabase.from("message_reactions").delete().match({ message_id: message.id, user_id: state.user.id });
      if (error) throw error;
    } else {
      // upsert reaction
      const { error } = await supabase.from("message_reactions").upsert({
        message_id: message.id,
        user_id: state.user.id,
        reaction: em
      }, { onConflict: ["message_id","user_id"] });
      if (error) throw error;
    }
  } catch(e){
    alert("–û—à–∏–±–∫–∞ —Ä–µ–∞–∫—Ü–∏–∏: " + e.message);
  }
}

async function sendMessage(){
  const inp = document.getElementById("messageInput");
  const text = inp.value.trim();
  if(!text) return;
  if(!state.activeChatId) return alert("–ß–∞—Ç –Ω–µ –≤—ã–±—Ä–∞–Ω");
  const payload = {
    chat_id: state.activeChatId,
    sender_id: state.user.id,
    text
  };
  const { data, error } = await supabase.from("messages").insert([payload]);
  if (error) return alert(error.message);
  inp.value = "";
  // message will come via realtime
}

/* ---------------- Realtime subscriptions ---------------- */
function subscribeRealtime(){
  // Unsubscribe old
  if (state.subMessages) state.subMessages.unsubscribe();
  if (state.subReactions) state.subReactions.unsubscribe();
  // messages
  state.subMessages = supabase
    .channel('public:messages')
    .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages' }, payload => {
      const m = payload.new;
      // append
      state.messages[m.chat_id] = state.messages[m.chat_id] || [];
      state.messages[m.chat_id].push(m);
      // update chat list last_message
      const chat = state.chats.find(c=>c.id===m.chat_id);
      if (chat){
        chat.last_message = m.text;
        chat.last_at = m.created_at;
      } else {
        // optionally add to chats list
      }
      // show notification if tab hidden and message not from me
      if (document.hidden && m.sender_id !== state.user.id) {
        (async ()=> {
          const ok = await notifyPermission();
          if (ok) {
            // fetch sender nickname
            const { data } = await supabase.from("profiles").select("nickname").eq("id", m.sender_id).single();
            const title = data?.nickname || "–ù–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ";
            new Notification(title, { body: m.text });
          }
        })();
      }
      // if active chat, re-render
      if (state.activeChatId === m.chat_id) renderMessages(m.chat_id);
      renderChatsList();
    })
    .subscribe();

  // reactions (INSERT, UPDATE, DELETE)
  state.subReactions = supabase
    .channel('public:reactions')
    .on('postgres_changes', { event: '*', schema: 'public', table: 'message_reactions' }, payload => {
      const ev = payload.eventType;
      const r = payload.new || payload.old;
      // rebuild reactions for affected message
      refreshReactionsForMessage(r.message_id);
    })
    .subscribe();
}

async function refreshReactionsForMessage(message_id){
  const { data, error } = await supabase.from("message_reactions").select("user_id,reaction").eq("message_id", message_id);
  if (error) return console.error(error);
  const obj = {counts:{}, byUser:null};
  (data||[]).forEach(r=>{
    obj.counts[r.reaction] = (obj.counts[r.reaction]||0)+1;
    if (r.user_id === state.user.id) obj.byUser = r.reaction;
  });
  state.reactions[message_id] = obj;
  // re-render messages if visible
  if (state.activeChatId) renderMessages(state.activeChatId);
}

/* ---------------- Helpers ---------------- */
function scrollToBottom(){
  const win = document.getElementById("messagesWindow");
  if (!win) return;
  win.scrollTop = win.scrollHeight + 1000;
}

/* ---------------- Init: auth state & start ---------------- */
(async function init(){
  // auth state change
  const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {
    if (session?.user){
      state.user = session.user;
      // load profile
      supabase.from("profiles").select("*").eq("id", state.user.id).single()
        .then(res=>{
          if (res.data) {
            state.profile = res.data;
            showMainUI();
          } else {
            showAuth();
            document.getElementById("nicknameSetup").style.display = "block";
          }
        });
    } else {
      state.user = null;
      state.profile = null;
      showAuth();
    }
  });
  // current session
  const { data: { user } } = await supabase.auth.getUser();
  if (user) {
    state.user = user;
    const { data: profile } = await supabase.from("profiles").select("*").eq("id", user.id).single();
    if (profile) { state.profile = profile; showMainUI(); } else showAuth();
  } else {
    showAuth();
  }

  // show online status (basic)
  onlineStatus.textContent = navigator.onLine ? "online" : "offline";
  window.addEventListener("online", ()=>onlineStatus.textContent = "online");
  window.addEventListener("offline", ()=>onlineStatus.textContent = "offline");

  // Request notifications permission early (optional)
  //await notifyPermission();
})();
</script>
</body>
</html>
