<!doctype html>
<!--
  index.html
  –ü–æ–ª–Ω—ã–π –æ–¥–Ω–æ—Å—Ç—Ä–∞–Ω–∏—á–Ω—ã–π –º–µ—Å—Å–µ–Ω–¥–∂–µ—Ä –Ω–∞ HTML+CSS+VanillaJS —Å Supabase.
  –ü–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º: –∑–∞–ø–æ–ª–Ω–∏—Ç—å SUPABASE_URL –∏ SUPABASE_ANON_KEY –≤ —Å–µ–∫—Ü–∏–∏ CONFIG.
  –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –≤–Ω—É—Ç—Ä–∏ –∫–æ–¥–∞ –ø–æ–º–æ–≥—É—Ç –æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å—Å—è –∏ —Ä–∞—Å—à–∏—Ä—è—Ç—å.
-->
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OneFile Messenger ‚Äî Supabase</title>

  <!-- Tailwind-like modern look without building - we write our CSS below -->
  <style>
    /* --- Reset & base --- */
    :root{
      --bg:#0f1724;
      --card:#0b1220;
      --muted:#94a3b8;
      --accent:#6ee7b7;
      --glass: rgba(255,255,255,0.03);
      --danger:#ff6b6b;
      --glass-2: rgba(255,255,255,0.02);
      --radius:12px;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    *{box-sizing:border-box}
    html,body,#app{height:100%; margin:0; background:linear-gradient(180deg,#071025 0%, var(--bg) 100%); color:#e6eef8;}
    a{color:inherit}
    /* --- Layout --- */
    .app {
      display:flex;
      gap:18px;
      padding:18px;
      height:100vh;
      align-items:stretch;
    }
    .sidebar {
      width:320px;
      min-width:240px;
      background:linear-gradient(180deg,var(--card), rgba(11,18,32,0.9));
      border-radius:var(--radius);
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:12px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
    }
    .main {
      flex:1;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-width:0;
    }
    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border-radius:12px;
      padding:12px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
    }

    /* --- Header --- */
    .topbar {
      height:60px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .search {
      display:flex;
      gap:8px;
      align-items:center;
      background:var(--glass);
      padding:8px;
      border-radius:10px;
    }
    .search input{
      background:transparent;
      border:0;
      outline:none;
      color:var(--muted);
      width:100%;
    }

    /* --- Chats list --- */
    .chats {
      display:flex;
      flex-direction:column;
      gap:8px;
      overflow:auto;
      padding-right:6px;
    }
    .chat-item {
      display:flex;
      gap:10px;
      align-items:center;
      padding:8px;
      border-radius:10px;
      cursor:pointer;
      transition:background .15s;
    }
    .chat-item:hover { background:var(--glass-2); }
    .chat-item.active { background:linear-gradient(90deg, rgba(110,231,183,0.08), transparent); box-shadow: 0 6px 14px rgba(12,20,28,0.4); }

    .avatar {
      width:44px;height:44px;border-radius:10px;flex-shrink:0;background:linear-gradient(90deg,#14374a,#1f2b3a);display:grid;place-items:center;font-weight:700;color:var(--accent)
    }
    .meta {flex:1; min-width:0}
    .meta .title { font-weight:600; font-size:14px; color:#e6f2ff; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .meta .subtitle { font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .badge { background:var(--accent); color:#022; min-width:22px; height:22px; display:inline-grid; place-items:center; padding:0 6px; border-radius:999px; font-weight:700; font-size:12px; }

    /* --- Chat area --- */
    .chat-area { display:flex; flex-direction:column; height: calc(100vh - 80px); min-height:0; }
    .messages {
      flex:1;
      overflow:auto;
      padding:18px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .message {
      max-width:70%;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      padding:10px 12px;
      border-radius:12px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.35);
      word-break:break-word;
    }
    .message.me { margin-left:auto; background:linear-gradient(180deg, rgba(110,231,183,0.08), rgba(110,231,183,0.02)); border:1px solid rgba(110,231,183,0.06); }
    .message .meta { font-size:12px; color:var(--muted); margin-bottom:6px; display:flex; gap:8px; align-items:center; }
    .message .content { font-size:14px; color:#e8f6f0; }
    .message .row { display:flex; gap:8px; align-items:center; margin-top:8px }
    .message .small { font-size:12px; color:var(--muted) }

    .compose {
      display:flex;
      gap:8px;
      padding:12px;
      align-items:center;
    }
    .compose textarea {
      flex:1; resize:none; min-height:48px; max-height:120px; padding:10px; border-radius:10px; border:0; outline:none; background:rgba(255,255,255,0.02); color:#e8f6f0;
    }
    .btn {
      background:linear-gradient(90deg,var(--accent), #34d399);
      color:#062018; padding:10px 12px; border-radius:10px; cursor:pointer; border:0; font-weight:700;
    }
    .btn.ghost { background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.03); }

    /* --- Modals, toasts --- */
    .modal {
      position:fixed; left:0; top:0; right:0; bottom:0; display:none; align-items:center; justify-content:center;
      background:rgba(2,6,23,0.6); z-index:50;
    }
    .modal.open{ display:flex; }
    .modal .card { width:720px; max-width:95%; background:linear-gradient(180deg, #071226, #05101b); border-radius:14px; padding:18px; box-shadow: 0 12px 40px rgba(0,0,0,0.7); }
    .row { display:flex; gap:8px; align-items:center; }
    .field { display:flex; flex-direction:column; gap:6px; }
    input, select { padding:10px; border-radius:10px; border:0; background:rgba(255,255,255,0.02); color:#e6eef8; min-width:0; outline:none; }
    label { font-size:13px; color:var(--muted) }

    .toast { position:fixed; right:18px; bottom:18px; background:linear-gradient(180deg,#0b1220, #071226); padding:12px 16px; border-radius:10px; box-shadow:0 8px 24px rgba(2,6,23,0.6); color:#dff7ea; display:none; z-index:60; }
    .toast.show { display:block; }

    /* --- Responsive --- */
    @media (max-width:880px){
      .sidebar { display:none; }
      .app { padding:8px; }
      .chat-area { height:calc(100vh - 18px); }
    }
  </style>
</head>
<body>
  <div id="app" class="app">
    <!-- Sidebar -->
    <div class="sidebar panel" id="sidebar">
      <div class="topbar">
        <div style="display:flex; gap:8px; align-items:center">
          <div style="font-weight:800; font-size:18px; color:var(--accent)">OneFile</div>
          <div style="color:var(--muted); font-size:13px">Messenger</div>
        </div>
        <div id="auth-controls">
          <!-- Sign in/up buttons or profile will be injected -->
        </div>
      </div>

      <div class="search">
        <input id="searchInput" placeholder="–ü–æ–∏—Å–∫ @nickname –∏–ª–∏ —á–∞—Ç..." />
        <button id="btnSearch" class="btn ghost">–ù–∞–π—Ç–∏</button>
      </div>

      <div style="display:flex; justify-content:space-between; align-items:center">
        <div style="font-weight:700; color:var(--muted)">–ß–∞—Ç—ã</div>
        <div style="display:flex; gap:8px">
          <button id="btnNewChat" class="btn ghost" title="–°–æ–∑–¥–∞—Ç—å —á–∞—Ç">–°–æ–∑–¥–∞—Ç—å</button>
        </div>
      </div>

      <div class="chats" id="chatsList" aria-live="polite"></div>

      <div style="margin-top:auto; display:flex; align-items:center; gap:10px">
        <div id="profilePreview" style="display:flex; gap:10px; align-items:center; width:100%">
          <!-- Avatar + nickname -->
        </div>
      </div>
    </div>

    <!-- Main area -->
    <div class="main">
      <div class="panel topbar" id="chatHeader">
        <div style="display:flex; gap:12px; align-items:center;">
          <div id="activeChatAvatar" class="avatar">?</div>
          <div>
            <div id="activeChatTitle" style="font-weight:700">–í—ã–±–µ—Ä–∏ —á–∞—Ç</div>
            <div id="activeChatSubtitle" style="font-size:12px; color:var(--muted)">–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —á–∞—Ç–µ</div>
          </div>
        </div>
        <div style="display:flex; gap:8px; align-items:center">
          <button id="btnAddMember" class="btn ghost">–î–æ–±–∞–≤–∏—Ç—å</button>
          <button id="btnLeaveChat" class="btn ghost">–í—ã–π—Ç–∏</button>
        </div>
      </div>

      <div class="panel chat-area">
        <div id="messages" class="messages" tabindex="0">
          <!-- Messages will be rendered here -->
        </div>

        <div class="compose">
          <button id="emojiBtn" class="btn ghost">üòä</button>
          <textarea id="messageInput" placeholder="–ù–∞–ø–∏—à–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ..." rows="2"></textarea>
          <button id="sendBtn" class="btn">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Modals -->
  <div id="modal" class="modal" role="dialog" aria-modal="true">
    <div class="card" id="modalCard">
      <!-- Content injected -->
    </div>
  </div>

  <!-- Toast -->
  <div id="toast" class="toast"></div>
<script>
  console.log('PLAIN SCRIPT WORKS');
</script>
  <!-- Dependencies: Supabase JS (ESM), Emoji picker (Emoji Button), simple icons from unpkg -->
  <script type="module">
     console.log('MODULE SCRIPT STARTED');
    // ======= CONFIG =======
  const SUPABASE_URL = 'https://vhcgcaerztzdqkmplbcg.supabase.co';
  const SUPABASE_ANON_KEY = 'sb_publishable_i1463Kqkkb8cQbX8t1Vb7Q_iBE4MTEd';
  const AVATARS_BUCKET = 'avatars';

  // ======= IMPORTS (–¢–û–õ–¨–ö–û esm.sh) =======
  import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
  import { EmojiButton } from 'https://esm.sh/@joeattardi/emoji-button@4.6.2';

  // ======= INIT SUPABASE =======
  const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
  window.supabase = supabase; // –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤ –∫–æ–Ω—Å–æ–ª–∏


    // ======= UI helpers =======
    const $ = (sel) => document.querySelector(sel);
    const $c = (tag, attrs = {}) => {
      const el = document.createElement(tag);
      Object.entries(attrs).forEach(([k,v])=>{
        if(k === 'class') el.className = v;
        else if(k === 'text') el.textContent = v;
        else el.setAttribute(k, v);
      });
      return el;
    };
    const toast = (text, time=3000) => {
      const t = $('#toast');
      t.textContent = text;
      t.classList.add('show');
      setTimeout(()=>t.classList.remove('show'), time);
    };
    const openModal = (contentHtml) => {
      $('#modalCard').innerHTML = contentHtml;
      $('#modal').classList.add('open');
    };
    const closeModal = () => $('#modal').classList.remove('open');

    // ======= State =======
    let currentUser = null; // profiles.id (uuid)
    let currentProfile = null; // profile object
    let activeChat = null; // chat object
    let chatsCache = {}; // chatId -> chat object
    let membersCache = {}; // chatId -> [members]
    let messagesCache = {}; // chatId -> [messages]
    let reactionsCache = {}; // messageId -> [reactions]

    // ======= Auth & profile handling =======
    // On load: check auth state
    window.addEventListener('DOMContentLoaded', initApp);
    async function initApp(){
      setupUIHandlers();
      // Listen to auth changes
      supabase.auth.onAuthStateChange(async (event, session) => {
        if(session?.user){
          await ensureProfile(session.user);
          await loadInitialData();
        } else {
          currentUser = null;
          currentProfile = null;
          renderAuthControls();
        }
      });

      // If already logged in
      const { data: { user } } = await supabase.auth.getUser();
      if(user){
        await ensureProfile(user);
        await loadInitialData();
      } else {
        renderAuthControls();
      }

      // Realtime listeners
      setupRealtime();
    }

    // Ensure there is a row in profiles for auth.user
    async function ensureProfile(authUser){
      // Try fetch profile
      const uid = authUser.id;
      const { data, error } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', uid)
        .single();
      if(error && error.code !== 'PGRST116'){ /* ignore not found */ }
      if(!data){
        // Create minimal profile with placeholder nickname (user must set nickname)
        const defaultNick = null;
        const { data: p, error: insertErr } = await supabase
          .from('profiles')
          .insert({ id: uid, nickname: defaultNick })
          .select()
          .single();
        if(insertErr) {
          console.error('profile create err', insertErr);
        } else currentProfile = p;
      } else {
        currentProfile = data;
      }
      currentUser = uid;
      renderAuthControls();
      renderProfilePreview();
      // If nickname missing - open modal to set
      if(!currentProfile.nickname){
        openProfileEditor({ requireNickname: true });
      }
    }

    // Render auth buttons / profile UI
    function renderAuthControls(){
      const el = $('#auth-controls');
      el.innerHTML = '';
      if(!currentUser){
        const btnIn = $c('button', { class: 'btn', text: '–í–æ–π—Ç–∏' });
        btnIn.onclick = () => openSignIn();
        const btnUp = $c('button', { class: 'btn ghost', text: '–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è' });
        btnUp.onclick = () => openSignUp();
        el.appendChild(btnIn);
        el.appendChild(btnUp);
      } else {
        const btnProfile = $c('button', { class: 'btn ghost', text: (currentProfile?.nickname || '–ü—Ä–æ—Ñ–∏–ª—å') });
        btnProfile.onclick = () => openProfileEditor();
        const btnOut = $c('button', { class: 'btn', text: '–í—ã–π—Ç–∏' });
        btnOut.onclick = async () => {
          await supabase.auth.signOut();
          currentUser = null;
          currentProfile = null;
          toast('–í—ã –≤—ã—à–ª–∏');
          renderAuthControls();
          clearUI();
        };
        el.appendChild(btnProfile);
        el.appendChild(btnOut);
      }
    }

    function renderProfilePreview(){
      const node = $('#profilePreview');
      node.innerHTML = '';
      if(!currentProfile) return;
      const av = $c('div', { class:'avatar' });
      if(currentProfile.avatar_url){
        av.style.background = `url(${currentProfile.avatar_url}) center/cover`;
        av.textContent = '';
      } else {
        av.textContent = (currentProfile.nickname || 'U').substring(0,2).toUpperCase();
      }
      const nick = $c('div');
      nick.innerHTML = `<div style="font-weight:700">${currentProfile.nickname || '‚Äî'}</div><div style="font-size:12px;color:var(--muted)">id: ${currentProfile.id?.slice(0,8)}</div>`;
      node.appendChild(av);
      node.appendChild(nick);
    }

    // ======= Sign In / Up / Profile Editor Modals =======
    function openSignIn(){
      openModal(`
        <h3>–í—Ö–æ–¥</h3>
        <div class="row" style="margin-top:8px">
          <div style="flex:1" class="field">
            <label>Email</label>
            <input id="si_email" placeholder="email" />
          </div>
        </div>
        <div class="row" style="margin-top:8px">
          <div style="flex:1" class="field">
            <label>–ü–∞—Ä–æ–ª—å</label>
            <input id="si_password" type="password" placeholder="–ø–∞—Ä–æ–ª—å" />
          </div>
        </div>
        <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:12px">
          <button id="si_btn" class="btn">–í–æ–π—Ç–∏</button>
          <button class="btn ghost" onclick="document.querySelector('#modal').classList.remove('open')">–û—Ç–º–µ–Ω–∞</button>
        </div>
      `);
      $('#si_btn').onclick = async () => {
        const email = $('#si_email').value.trim();
        const password = $('#si_password').value;
        if(!email || !password) return toast('–ó–∞–ø–æ–ª–Ω–∏ –ø–æ–ª—è');
        const { error } = await supabase.auth.signInWithPassword({ email, password });
        if(error) toast('–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞: ' + error.message);
        else { closeModal(); toast('–í—Ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω'); }
      };
    }

    function openSignUp(){
      openModal(`
        <h3>–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è</h3>
        <div class="row" style="margin-top:8px">
          <div style="flex:1" class="field">
            <label>Email</label>
            <input id="su_email" placeholder="email" />
          </div>
        </div>
        <div class="row" style="margin-top:8px">
          <div style="flex:1" class="field">
            <label>–ü–∞—Ä–æ–ª—å</label>
            <input id="su_password" type="password" placeholder="–ø–∞—Ä–æ–ª—å (min 6)" />
          </div>
        </div>
        <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:12px">
          <button id="su_btn" class="btn">–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è</button>
          <button class="btn ghost" onclick="document.querySelector('#modal').classList.remove('open')">–û—Ç–º–µ–Ω–∞</button>
        </div>
      `);
      $('#su_btn').onclick = async () => {
        const email = $('#su_email').value.trim();
        const password = $('#su_password').value;
        if(!email || !password) return toast('–ó–∞–ø–æ–ª–Ω–∏ –ø–æ–ª—è');
        const { data, error } = await supabase.auth.signUp({ email, password });
        if(error) toast('–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: ' + error.message);
        else {
          toast('–ü–∏—Å—å–º–æ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ. –î–∞–ª—å—à–µ –Ω—É–∂–Ω–æ –∑–∞–¥–∞—Ç—å @nickname.');
          closeModal();
        }
      };
    }

    // Profile editor: set nickname, upload avatar
    function openProfileEditor(opts = {}){
      const requireNickname = !!opts.requireNickname;
      openModal(`
        <h3>–ü—Ä–æ—Ñ–∏–ª—å</h3>
        <div style="display:flex; gap:12px; margin-top:8px">
          <div style="width:120px">
            <div id="pe_avatar" class="avatar" style="width:120px;height:120px;border-radius:14px"></div>
          </div>
          <div style="flex:1">
            <div class="field">
              <label>–ù–∏–∫–Ω–µ–π–º (—Ñ–æ—Ä–º–∞—Ç: @nickname)</label>
              <input id="pe_nickname" placeholder="@nick" value="${currentProfile?.nickname ? currentProfile.nickname : ''}" />
              <div style="font-size:12px;color:var(--muted)">–ù–∏–∫–Ω–µ–π–º –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º. –ë–µ–∑ –ø—Ä–æ–±–µ–ª–æ–≤, —Ç–æ–ª—å–∫–æ –ª–∞—Ç–∏–Ω—Å–∫–∏–µ –±—É–∫–≤—ã, —Ü–∏—Ñ—Ä—ã –∏ –ø–æ–¥—á—ë—Ä–∫–∏–≤–∞–Ω–∏—è.</div>
            </div>
            <div style="display:flex; gap:8px; margin-top:8px">
              <input id="pe_avatar_file" type="file" accept="image/*" />
              <button id="pe_upload" class="btn ghost">–ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
            </div>
            <div style="margin-top:10px; display:flex; gap:8px; justify-content:flex-end">
              <button id="pe_save" class="btn">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
              <button class="btn ghost" id="pe_close">–ó–∞–∫—Ä—ã—Ç—å</button>
            </div>
          </div>
        </div>
      `);
      const av = $('#pe_avatar');
      if(currentProfile?.avatar_url) av.style.background = `url(${currentProfile.avatar_url}) center/cover`;
      $('#pe_close').onclick = closeModal;
      $('#pe_upload').onclick = async () => {
        const file = $('#pe_avatar_file').files?.[0];
        if(!file) return toast('–í—ã–±–µ—Ä–∏ —Ñ–∞–π–ª');
        const ext = file.name.split('.').pop();
        const fileName = `avatars/${currentUser}/${Date.now()}.${ext}`;
        const up = await supabase.storage.from(AVATARS_BUCKET).upload(fileName, file, { cacheControl: '3600', upsert: true });
        if(up.error) return toast('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ' + up.error.message);
        // get public url
        const { data: publicUrl } = supabase.storage.from(AVATARS_BUCKET).getPublicUrl(fileName);
        // update profile.avatar_url
        const { error } = await supabase.from('profiles').update({ avatar_url: publicUrl.publicUrl }).eq('id', currentUser);
        if(error) return toast('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è: ' + error.message);
        currentProfile.avatar_url = publicUrl.publicUrl;
        av.style.background = `url(${publicUrl.publicUrl}) center/cover`;
        renderProfilePreview();
        toast('–ê–≤–∞—Ç–∞—Ä –æ–±–Ω–æ–≤–ª—ë–Ω');
      };
      $('#pe_save').onclick = async () => {
        let nick = $('#pe_nickname').value.trim();
        if(!nick && requireNickname) return toast('–ù—É–∂–Ω–æ –∑–∞–¥–∞—Ç—å @nickname');
        if(nick && !nick.startsWith('@')) nick = '@' + nick;
        // validation: only @ + letters, numbers, underscores, dots
        if(nick && !/^@[A-Za-z0-9_\.]{3,32}$/.test(nick)) return toast('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–∏–∫–Ω–µ–π–º–∞');
        // Check uniqueness (server-side also enforced)
        if(nick){
          const { data: exist } = await supabase.from('profiles').select('id').ilike('nickname', nick).limit(1);
          if(exist && exist.length && exist[0].id !== currentUser) return toast('–ù–∏–∫–Ω–µ–π–º —É–∂–µ –∑–∞–Ω—è—Ç');
        }
        const { error } = await supabase.from('profiles').update({ nickname: nick || null }).eq('id', currentUser);
        if(error) return toast('–û—à–∏–±–∫–∞: ' + error.message);
        currentProfile.nickname = nick || null;
        renderProfilePreview();
        closeModal();
        toast('–ü—Ä–æ—Ñ–∏–ª—å —Å–æ—Ö—Ä–∞–Ω—ë–Ω');
      };
    }

    // ======= Loading chats / messages =======
    async function loadInitialData(){
      await loadChatsList();
      renderAuthControls();
    }

    async function loadChatsList(){
      if(!currentUser) return;
      // Get chats where user is member; include last message info via messages lateral
      const { data, error } = await supabase
        .from('chats')
        .select(`
          id, name, avatar_url, is_group, creator,
          chat_members!inner(user_id, role, last_read_at, joined_at),
          messages:messages(*)
        `)
        .in('id', supabase.rpc ? undefined : []); // placeholder to avoid linting
      // Above heavy select may not be optimal. Use two queries instead.

      // Fetch chats where user is a member
      const { data: chats, error: cErr } = await supabase
        .from('chats')
        .select('id,name,avatar_url,is_group,creator,created_at')
        .in('id', [])
        .limit(100); // shim
      // Instead do a join using RPC-like query:
      const { data: myChats, error: err2 } = await supabase
        .from('chats')
        .select('id,name,avatar_url,is_group,creator,created_at')
        .in('id',
            (await supabase.from('chat_members').select('chat_id').eq('user_id', currentUser).then(r=>r.data.map(x=>x.chat_id)))
         );

      if(err2) {
        console.error('load chats err', err2);
        return;
      }
      // store chats
      chatsCache = {};
      for(const c of myChats){
        chatsCache[c.id] = c;
      }
      // Load chat members and last messages separately
      await Promise.all(Object.keys(chatsCache).map(cid => loadChatMeta(cid)));
      renderChatsList();
    }

    async function loadChatMeta(chatId){
      // members
      const { data: members } = await supabase
        .from('chat_members')
        .select('user_id,role,joined_at,last_read_at,profiles(id,nickname,avatar_url)')
        .eq('chat_id', chatId);
      membersCache[chatId] = members || [];

      // last messages (limit 1)
      const { data: msgs } = await supabase
        .from('messages')
        .select('id,chat_id,sender_id,content,created_at,edited,deleted')
        .eq('chat_id', chatId)
        .order('created_at', { ascending:false })
        .limit(1);
      messagesCache[chatId] = msgs ? msgs.slice().reverse() : [];
    }

    function renderChatsList(){
      const list = $('#chatsList');
      list.innerHTML = '';
      const chatEntries = Object.values(chatsCache).sort((a,b)=> new Date(b.created_at) - new Date(a.created_at));
      for(const c of chatEntries){
        const item = $c('div', { class:'chat-item', id:'chat-'+c.id });
        item.onclick = async () => {
          await openChat(c.id);
        };
        const av = $c('div', { class:'avatar' });
        if(c.avatar_url) av.style.background = `url(${c.avatar_url}) center/cover`;
        else av.textContent = c.name ? c.name.charAt(0).toUpperCase() : 'C';
        const meta = $c('div', { class:'meta' });
        const title = $c('div', { class:'title', text: c.is_group ? (c.name || '–ì—Ä—É–ø–ø–∞') : '–õ–∏—á–Ω—ã–π —á–∞—Ç' });
        const subtitle = $c('div', { class:'subtitle', text: '–ó–∞–≥—Ä—É–∑–∫–∞...' });
        // last message preview
        const msgs = messagesCache[c.id] || [];
        if(msgs.length){
          const m = msgs[msgs.length-1];
          subtitle.textContent = (m.deleted ? '–°–æ–æ–±—â–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–æ' : (m.content || '').slice(0,40)) + (m.edited ? ' (–æ—Ç—Ä–µ–¥.)' : '');
        } else subtitle.textContent = '–ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π';
        meta.appendChild(title); meta.appendChild(subtitle);
        // unread counter
        const member = (membersCache[c.id] || []).find(m => m.user_id === currentUser);
        const unread = computeUnreadCount(c.id, member);
        const right = $c('div');
        if(unread > 0){
          const b = $c('div', { class:'badge', text: String(unread) });
          right.appendChild(b);
        }
        item.appendChild(av);
        item.appendChild(meta);
        item.appendChild(right);
        list.appendChild(item);
      }
    }

    function computeUnreadCount(chatId, member){
      if(!member) return 0;
      const lastRead = member.last_read_at ? new Date(member.last_read_at) : null;
      const msgs = messagesCache[chatId] || [];
      if(!msgs.length) return 0;
      let cnt = 0;
      for(const m of msgs){
        if(!lastRead || new Date(m.created_at) > lastRead) cnt++;
      }
      return cnt;
    }

    // ======= Open chat, render messages =======
    async function openChat(chatId){
      if(!chatId) return;
      activeChat = chatsCache[chatId];
      if(!activeChat){
        // load chat from server
        const { data } = await supabase.from('chats').select('*').eq('id', chatId).single();
        chatsCache[chatId] = data;
        activeChat = data;
      }
      // highlight in UI
      document.querySelectorAll('.chat-item').forEach(n=>n.classList.remove('active'));
      const node = document.getElementById('chat-'+chatId);
      if(node) node.classList.add('active');
      // render header
      $('#activeChatAvatar').style.background = activeChat.avatar_url ? `url(${activeChat.avatar_url}) center/cover` : '';
      $('#activeChatAvatar').textContent = activeChat.avatar_url ? '' : (activeChat.name || 'C').charAt(0).toUpperCase();
      $('#activeChatTitle').textContent = activeChat.is_group ? (activeChat.name || '–ì—Ä—É–ø–ø–∞') : renderPrivateTitle(chatId);
      $('#activeChatSubtitle').textContent = '–ó–∞–≥—Ä—É–∑–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π...';

      // load messages (last 200)
      const { data: msgs } = await supabase
        .from('messages')
        .select('id,chat_id,sender_id,content,created_at,updated_at,edited,deleted')
        .eq('chat_id', chatId)
        .order('created_at', { ascending:true })
        .limit(1000);
      messagesCache[chatId] = msgs || [];
      // load members
      const { data: members } = await supabase.from('chat_members').select('user_id,role,last_read_at,profiles(id,nickname,avatar_url)').eq('chat_id', chatId);
      membersCache[chatId] = members || [];

      // render
      renderMessages(chatId);
      // mark as read (update last_read_at)
      await supabase.from('chat_members').update({ last_read_at: new Date().toISOString() }).eq('chat_id', chatId).eq('user_id', currentUser);
    }

    function renderPrivateTitle(chatId){
      const members = membersCache[chatId] || [];
      const other = members.find(m => m.user_id !== currentUser);
      if(other && other.profiles) return other.profiles.nickname || other.profiles.id.slice(0,8);
      return '–õ–∏—á–Ω—ã–π —á–∞—Ç';
    }

    function renderMessages(chatId){
      const root = $('#messages');
      root.innerHTML = '';
      const msgs = messagesCache[chatId] || [];
      for(const m of msgs){
        const isMe = m.sender_id === currentUser;
        const msg = $c('div', { class: 'message ' + (isMe ? 'me' : '') });
        const meta = $c('div', { class:'meta' });
        const senderProfile = getProfileForId(m.sender_id);
        const senderName = senderProfile?.nickname || (m.sender_id?.slice(0,8) || 'Unknown');
        meta.innerHTML = `<div style="font-weight:700">${senderName}</div><div style="font-size:12px;color:var(--muted)">${new Date(m.created_at).toLocaleString()}</div>`;
        if(m.edited) meta.innerHTML += `<div style="font-size:12px;color:var(--muted);margin-left:8px">(–æ—Ç—Ä–µ–¥.)</div>`;
        const content = $c('div', { class:'content', text: m.deleted ? '–°–æ–æ–±—â–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–æ' : m.content });
        msg.appendChild(meta);
        msg.appendChild(content);
        // actions row
        const row = $c('div', { class:'row' });
        const small = $c('div', { class:'small', text: '' });
        // reactions preview (basic)
        const reacts = reactionsCache[m.id] || [];
        if(reacts.length){
          small.textContent = reacts.map(r=>r.emoji).join(' ');
        }
        row.appendChild(small);
        // if mine - edit/delete buttons
        if(isMe && !m.deleted){
          const edit = $c('button', { class:'btn ghost', text:'–†–µ–¥.' });
          edit.onclick = () => openEditMessage(m);
          const del = $c('button', { class:'btn ghost', text:'–£–¥–∞–ª.' });
          del.onclick = () => deleteMessageConfirm(m.id);
          row.appendChild(edit);
          row.appendChild(del);
        }
        // reaction button
        const rbtn = $c('button', { class:'btn ghost', text:'‚ù§' });
        rbtn.onclick = () => openEmojiForMessage(m.id);
        row.appendChild(rbtn);

        msg.appendChild(row);
        root.appendChild(msg);
      }
      setTimeout(()=>root.scrollTop = root.scrollHeight, 100);
    }

    // Helper: get minimal profile cached from members, else fetch
    function getProfileForId(uid){
      for(const mid in membersCache){
        const m = (membersCache[mid] || []).find(x => x.user_id === uid);
        if(m && m.profiles) return m.profiles;
      }
      if(currentProfile?.id === uid) return currentProfile;
      return null;
    }

    // ======= Sending messages =======
    function setupUIHandlers(){
      $('#sendBtn').onclick = sendMessage;
      $('#messageInput').addEventListener('keydown', (e) => {
        if(e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
      });
      $('#btnNewChat').onclick = openCreateChat;
      $('#btnAddMember').onclick = openAddMemberModal;
      $('#btnLeaveChat').onclick = leaveChatConfirm;
      $('#btnSearch').onclick = handleSearch;
      $('#searchInput').addEventListener('keydown', (e)=> { if(e.key==='Enter') handleSearch(); });

      // emoji picker
      const picker = new EmojiButton({ position: 'top-end', zIndex: 9999 });
      $('#emojiBtn').addEventListener('click', () => picker.togglePicker($('#emojiBtn')));
      picker.on('emoji', emoji => {
        const area = $('#messageInput');
        area.value = area.value + emoji;
        area.focus();
      });

      // modal close on backdrop click
      $('#modal').addEventListener('click', (e) => {
        if(e.target === $('#modal')) closeModal();
      });
    }

    async function sendMessage(){
      if(!activeChat) return toast('–í—ã–±–µ—Ä–∏ —á–∞—Ç');
      const content = $('#messageInput').value.trim();
      if(!content) return;
      const payload = {
        chat_id: activeChat.id,
        sender_id: currentUser,
        content,
        created_at: new Date().toISOString()
      };
      const { data, error } = await supabase.from('messages').insert(payload).select().single();
      if(error) return toast('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: ' + error.message);
      $('#messageInput').value = '';
      // messagesCache will be updated via realtime subscription
      // update chat last activity maybe via trigger on server
    }

    async function openEditMessage(message){
      openModal(`
        <h3>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ</h3>
        <div class="field" style="margin-top:8px">
          <textarea id="edit_content" rows="4">${escapeHtml(message.content)}</textarea>
        </div>
        <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:8px">
          <button id="edit_save" class="btn">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
          <button class="btn ghost" onclick="document.querySelector('#modal').classList.remove('open')">–û—Ç–º–µ–Ω–∞</button>
        </div>
      `);
      $('#edit_save').onclick = async () => {
        const newContent = $('#edit_content').value.trim();
        if(!newContent) return toast('–°–æ–æ–±—â–µ–Ω–∏–µ –ø—É—Å—Ç–æ–µ');
        const { error } = await supabase.from('messages').update({ content: newContent, edited: true, updated_at: new Date().toISOString() }).eq('id', message.id).eq('sender_id', currentUser);
        if(error) return toast('–û—à–∏–±–∫–∞: ' + error.message);
        closeModal();
        toast('–°–æ–æ–±—â–µ–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ');
      };
    }

    async function deleteMessageConfirm(messageId){
      if(!confirm('–£–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ?')) return;
      const { error } = await supabase.from('messages').update({ deleted: true, content: null }).eq('id', messageId).eq('sender_id', currentUser);
      if(error) return toast('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è: ' + error.message);
      toast('–°–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–º–µ—á–µ–Ω–æ —É–¥–∞–ª—ë–Ω–Ω—ã–º');
    }

    function openEmojiForMessage(messageId){
      const emojiPicker = new EmojiButton({ position: 'top-end', zIndex: 9999 });
      emojiPicker.on('emoji', async (emoji) => {
        // toggle reaction: if user already reacted with same emoji -> remove; else insert
        const existing = (reactionsCache[messageId] || []).find(r => r.user_id === currentUser && r.emoji === emoji);
        if(existing){
          await supabase.from('message_reactions').delete().eq('message_id', messageId).eq('user_id', currentUser).eq('emoji', emoji);
        } else {
          await supabase.from('message_reactions').insert({ message_id: messageId, user_id: currentUser, emoji });
        }
      });
      emojiPicker.pickerVisible ? emojiPicker.hidePicker() : emojiPicker.showPicker($('#emojiBtn'));
    }

    function escapeHtml(s){
      return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    // ======= Chat CRUD =======
    function openCreateChat(){
      openModal(`
        <h3>–°–æ–∑–¥–∞—Ç—å —á–∞—Ç</h3>
        <div class="field" style="margin-top:8px">
          <label>–ù–∞–∑–≤–∞–Ω–∏–µ (–¥–ª—è –≥—Ä—É–ø–ø–æ–≤–æ–≥–æ —á–∞—Ç–∞)</label>
          <input id="cc_name" placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ –≥—Ä—É–ø–ø—ã (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)" />
        </div>
        <div class="field" style="margin-top:8px">
          <label>–¢–∏–ø</label>
          <select id="cc_type"><option value="private">–õ–∏—á–Ω—ã–π (1:1)</option><option value="group">–ì—Ä—É–ø–ø–∞</option></select>
        </div>
        <div class="field" style="margin-top:8px">
          <label>–î–æ–±–∞–≤–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ (@nickname, —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é)</label>
          <input id="cc_members" placeholder="@alice,@bob" />
        </div>
        <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:8px">
          <button id="cc_create" class="btn">–°–æ–∑–¥–∞—Ç—å</button>
          <button class="btn ghost" onclick="document.querySelector('#modal').classList.remove('open')">–û—Ç–º–µ–Ω–∞</button>
        </div>
      `);
      $('#cc_create').onclick = async () => {
        const type = $('#cc_type').value;
        const isGroup = type === 'group';
        const name = $('#cc_name').value.trim();
        const raw = $('#cc_members').value.trim();
        const nicks = raw.split(',').map(s=>s.trim()).filter(Boolean);
        // Resolve nicknames to user ids
        const users = [];
        if(nicks.length){
          const { data: found } = await supabase.from('profiles').select('id,nickname,avatar_url').in('nickname', nicks);
          if(found && found.length) users.push(...found);
        }
        // If private and only one target - create direct chat with that user
        if(!isGroup && users.length === 1){
          // Check if chat between two exists
          const otherId = users[0].id;
          // Query for chats where chat_members = [currentUser, otherId] and is_group=false
          const { data: pairs } = await supabase.rpc('find_private_chat', { user_a: currentUser, user_b: otherId });
          if(pairs && pairs.length){
            closeModal();
            openChat(pairs[0].id);
            return;
          }
        }

        // Create chat
        const { data: chat, error } = await supabase.from('chats').insert({
          name: isGroup ? (name || '–ì—Ä—É–ø–ø–∞') : null,
          is_group: isGroup,
          creator: currentUser
        }).select().single();
        if(error) return toast('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è: ' + error.message);
        // Add creator as member
        const membersToInsert = [{ chat_id: chat.id, user_id: currentUser, role: 'creator' }];
        for(const u of users){
          membersToInsert.push({ chat_id: chat.id, user_id: u.id, role: 'member' });
        }
        await supabase.from('chat_members').insert(membersToInsert);
        chatsCache[chat.id] = chat;
        closeModal();
        await loadChatMeta(chat.id);
        renderChatsList();
        openChat(chat.id);
      };
    }

    function openAddMemberModal(){
      if(!activeChat) return toast('–í—ã–±–µ—Ä–∏ —á–∞—Ç');
      openModal(`
        <h3>–î–æ–±–∞–≤–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∞</h3>
        <div class="field" style="margin-top:8px">
          <label>@nickname</label>
          <input id="am_nick" placeholder="@nick" />
        </div>
        <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:8px">
          <button id="am_add" class="btn">–î–æ–±–∞–≤–∏—Ç—å</button>
          <button class="btn ghost" onclick="document.querySelector('#modal').classList.remove('open')">–û—Ç–º–µ–Ω–∞</button>
        </div>
      `);
      $('#am_add').onclick = async () => {
        let nick = $('#am_nick').value.trim();
        if(!nick) return toast('–í–≤–µ–¥–∏—Ç–µ @nickname');
        if(!nick.startsWith('@')) nick = '@' + nick;
        const { data: found } = await supabase.from('profiles').select('id,nickname').eq('nickname', nick).single();
        if(!found) return toast('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω');
        // Insert into chat_members if not exists
        const { data: existing } = await supabase.from('chat_members').select('*').eq('chat_id', activeChat.id).eq('user_id', found.id).single();
        if(existing) return toast('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –≤ —á–∞—Ç–µ');
        const { error } = await supabase.from('chat_members').insert({ chat_id: activeChat.id, user_id: found.id, role: 'member' });
        if(error) return toast('–û—à–∏–±–∫–∞: ' + error.message);
        toast('–£—á–∞—Å—Ç–Ω–∏–∫ –¥–æ–±–∞–≤–ª–µ–Ω');
        closeModal();
      };
    }

    async function leaveChatConfirm(){
      if(!activeChat) return;
      if(!confirm('–í—ã–π—Ç–∏ –∏–∑ —á–∞—Ç–∞?')) return;
      // If creator -> cannot leave (must delete)
      if(activeChat.creator === currentUser){
        if(!confirm('–¢—ã —Å–æ–∑–¥–∞—Ç–µ–ª—å —á–∞—Ç–∞. –£–¥–∞–ª–∏—Ç—å —á–∞—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é?')) return;
        const { error } = await supabase.from('chats').delete().eq('id', activeChat.id).eq('creator', currentUser);
        if(error) return toast('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —á–∞—Ç–∞: ' + error.message);
        toast('–ß–∞—Ç —É–¥–∞–ª—ë–Ω');
        delete chatsCache[activeChat.id];
        activeChat = null;
        renderChatsList();
        clearMessages();
        return;
      }
      const { error } = await supabase.from('chat_members').delete().eq('chat_id', activeChat.id).eq('user_id', currentUser);
      if(error) return toast('–û—à–∏–±–∫–∞ –≤—ã—Ö–æ–¥–∞: ' + error.message);
      toast('–¢—ã –≤—ã—à–µ–ª –∏–∑ —á–∞—Ç–∞');
      delete chatsCache[activeChat.id];
      activeChat = null;
      renderChatsList();
      clearMessages();
    }

    function clearMessages(){
      $('#messages').innerHTML = '';
      $('#activeChatTitle').textContent = '–í—ã–±–µ—Ä–∏ —á–∞—Ç';
      $('#activeChatSubtitle').textContent = '–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —á–∞—Ç–µ';
      $('#activeChatAvatar').style.background = '';
      $('#activeChatAvatar').textContent = '?';
    }

    function clearUI(){
      document.getElementById('chatsList').innerHTML = '';
      clearMessages();
    }

    // ======= Search users & chats =======
    async function handleSearch(){
      const q = $('#searchInput').value.trim();
      if(!q) return;
      // If starts with @ -> search users
      if(q.startsWith('@')){
        const nick = q;
        const { data } = await supabase.from('profiles').select('id,nickname,avatar_url').ilike('nickname', nick + '%').limit(20);
        if(!data || !data.length) return toast('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã');
        // Show results modal
        openModal(`<h3>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞</h3><div id="searchResults" style="margin-top:8px"></div>`);
        const container = $('#searchResults');
        for(const p of data){
          const item = $c('div', { class:'chat-item' });
          item.onclick = async () => {
            // Start private chat
            const otherId = p.id;
            // Use RPC to find or create private chat
            const { data: existing } = await supabase.rpc('find_or_create_private_chat', { user_a: currentUser, user_b: otherId });
            if(existing && existing.id){
              closeModal();
              chatsCache[existing.id] = existing;
              await loadChatMeta(existing.id);
              renderChatsList();
              openChat(existing.id);
            } else toast('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –ª–∏—á–Ω—ã–π —á–∞—Ç');
          };
          const av = $c('div', { class:'avatar' });
          if(p.avatar_url) av.style.background = `url(${p.avatar_url}) center/cover`;
          else av.textContent = (p.nickname || 'U').substring(0,2).toUpperCase();
          const meta = $c('div', { class:'meta' });
          meta.innerHTML = `<div class="title">${p.nickname}</div><div class="subtitle">${p.id.slice(0,8)}</div>`;
          item.appendChild(av); item.appendChild(meta);
          container.appendChild(item);
        }
      } else {
        // Search chats
        const { data } = await supabase.from('chats').select('id,name,avatar_url,is_group').ilike('name', `%${q}%`).limit(30);
        if(!data || !data.length) return toast('–ß–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã');
        openModal(`<h3>–ß–∞—Ç—ã</h3><div id="searchChats" style="margin-top:8px"></div>`);
        const cont = $('#searchChats');
        for(const c of data){
          const it = $c('div', { class:'chat-item' });
          it.onclick = async () => { closeModal(); chatsCache[c.id] = c; await loadChatMeta(c.id); renderChatsList(); openChat(c.id); };
          const av = $c('div', { class:'avatar' });
          if(c.avatar_url) av.style.background = `url(${c.avatar_url}) center/cover`;
          else av.textContent = (c.name || 'C').charAt(0).toUpperCase();
          const meta = $c('div', { class:'meta' });
          meta.innerHTML = `<div class="title">${c.name || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'}</div><div class="subtitle">${c.is_group ? '–ì—Ä—É–ø–ø–∞' : '–ß–∞—Ç'}</div>`;
          it.appendChild(av); it.appendChild(meta);
          cont.appendChild(it);
        }
      }
    }

    // ======= Realtime subscriptions =======
    function setupRealtime(){
      // Subscribe to messages changes for chats the user is member of
      // Use postgres_changes channel
      const channel = supabase.channel('public:messages')
        .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages' }, payload => {
          const record = payload.new;
          // push to cache and re-render if chat open
          messagesCache[record.chat_id] = messagesCache[record.chat_id] || [];
          messagesCache[record.chat_id].push(record);
          // Update chat last message in chat list
          loadChatMeta(record.chat_id).then(()=>renderChatsList());
          if(activeChat && activeChat.id === record.chat_id) renderMessages(record.chat_id);
          // Show notification badge if not active
          if(!activeChat || activeChat.id !== record.chat_id){
            highlightChat(record.chat_id);
          }
        })
        .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'messages' }, payload => {
          const rec = payload.new;
          const list = messagesCache[rec.chat_id] || [];
          const idx = list.findIndex(m => m.id === rec.id);
          if(idx >= 0) list[idx] = rec;
          else list.push(rec);
          if(activeChat && activeChat.id === rec.chat_id) renderMessages(rec.chat_id);
          loadChatMeta(rec.chat_id).then(()=>renderChatsList());
        })
        .on('postgres_changes', { event: 'DELETE', schema: 'public', table: 'messages' }, payload => {
          const rec = payload.old;
          const list = messagesCache[rec.chat_id] || [];
          messagesCache[rec.chat_id] = list.filter(m => m.id !== rec.id);
          if(activeChat && activeChat.id === rec.chat_id) renderMessages(rec.chat_id);
          loadChatMeta(rec.chat_id).then(()=>renderChatsList());
        })
        // chat_members changes (for new membership)
        .on('postgres_changes', { event: '*', schema: 'public', table: 'chat_members' }, payload => {
          // reload chat meta for affected chat
          const rec = payload.new || payload.old;
          if(rec?.chat_id) loadChatMeta(rec.chat_id).then(()=>renderChatsList());
        })
        // reactions
        .on('postgres_changes', { event: '*', schema: 'public', table: 'message_reactions' }, payload => {
          const rec = payload.new || payload.old;
          if(!rec) return;
          // refresh reactionsCache for message
          refreshReactions(rec.message_id);
          if(activeChat && activeChat.id) renderMessages(activeChat.id);
        })
        .subscribe();
    }

    async function refreshReactions(messageId){
      const { data } = await supabase.from('message_reactions').select('*').eq('message_id', messageId);
      reactionsCache[messageId] = data || [];
    }
    
    function highlightChat(chatId){
      const node = document.getElementById('chat-'+chatId);
      if(node) node.classList.add('active');
      // increment badge count by 1 (naive)
      const badge = node?.querySelector('.badge');
      if(badge) badge.textContent = String(Number(badge.textContent || 0) + 1);
    }

    // ======= Utility: RPC functions assumptions =======
    // The SQL below includes RPC functions `find_private_chat` and `find_or_create_private_chat`.
    // If they don't exist, the create-private-chat path will fail; but front-end guards still work.

    // ======= End of app code =======
  </script>
</body>
</html>
